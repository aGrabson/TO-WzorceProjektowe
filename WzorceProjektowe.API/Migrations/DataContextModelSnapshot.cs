// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using WzorceProjektowe.API.Data;

#nullable disable

namespace WzorceProjektowe.API.Migrations
{
    [DbContext(typeof(DataContext))]
    partial class DataContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "6.0.28")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder, 1L, 1);

            modelBuilder.Entity("WzorceProjektowe.API.Entities.PatternEntity", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uniqueidentifier");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DynamicMethodAC")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DynamicMethodACJava")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DynamicMethodC")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DynamicMethodCJava")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DynamicMethodI")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DynamicMethodIJava")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DynamicsCode")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("DynamicsCodeJava")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Schema")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("SchemaJava")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("ToInterpret")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("Id");

                    b.ToTable("Patterns");

                    b.HasData(
                        new
                        {
                            Id = new Guid("21ada38f-cd9b-4231-b564-d6c5f3412260"),
                            Description = "The Adapter pattern allows objects with incompatible interfaces to collaborate.",
                            DynamicMethodAC = "",
                            DynamicMethodACJava = "",
                            DynamicMethodC = "",
                            DynamicMethodCJava = "",
                            DynamicMethodI = "",
                            DynamicMethodIJava = "",
                            DynamicsCode = "",
                            DynamicsCodeJava = "",
                            Name = "Adapter",
                            Schema = "interface ITarget {\r\n    void Request();\r\n}\r\n\r\nclass Adaptee {\r\n    public void SpecificRequest() {\r\n        Console.WriteLine(\"Specific request\");\r\n    }\r\n}\r\n\r\nclass Adapter : ITarget {\r\n    private Adaptee _adaptee;\r\n\r\n    public Adapter(Adaptee adaptee) {\r\n        _adaptee = adaptee;\r\n    }\r\n\r\n    public void Request() {\r\n        _adaptee.SpecificRequest();\r\n    }\r\n}\r\n\r\nclass Client {\r\n    static void Main(string[] args) {\r\n        Adaptee adaptee = new Adaptee();\r\n        ITarget adapter = new Adapter(adaptee);\r\n        adapter.Request();\r\n    }\r\n}",
                            SchemaJava = "",
                            ToInterpret = "",
                            Type = "Structural"
                        },
                        new
                        {
                            Id = new Guid("249dbdc9-acc3-449d-8968-634c089e7ba1"),
                            Description = "The Bridge pattern decouples an abstraction from its implementation so that the two can vary independently.",
                            DynamicMethodAC = "",
                            DynamicMethodACJava = "",
                            DynamicMethodC = "",
                            DynamicMethodCJava = "",
                            DynamicMethodI = "",
                            DynamicMethodIJava = "",
                            DynamicsCode = "",
                            DynamicsCodeJava = "",
                            Name = "Bridge",
                            Schema = "",
                            SchemaJava = "",
                            ToInterpret = "",
                            Type = "Structural"
                        },
                        new
                        {
                            Id = new Guid("493b34a1-12e1-4967-aa6c-a54cd9d147f9"),
                            Description = "The Composite pattern composes objects into tree structures to represent part-whole hierarchies.",
                            DynamicMethodAC = "",
                            DynamicMethodACJava = "",
                            DynamicMethodC = "",
                            DynamicMethodCJava = "",
                            DynamicMethodI = "",
                            DynamicMethodIJava = "",
                            DynamicsCode = "",
                            DynamicsCodeJava = "",
                            Name = "Composite",
                            Schema = "",
                            SchemaJava = "",
                            ToInterpret = "",
                            Type = "Structural"
                        },
                        new
                        {
                            Id = new Guid("6469a535-507a-44fd-b9d7-dcf831847a21"),
                            Description = "The Decorator pattern attaches additional responsibilities to objects dynamically.",
                            DynamicMethodAC = "\r\n    public virtual #TYPE# #NAME#(#PARAMS#){\r\n        component.#NAME#(#NOTYPEPARAMS#);\r\n    }",
                            DynamicMethodACJava = "\r\n    @Override\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        component.#NAME#(#NOTYPEPARAMS#);\r\n    }",
                            DynamicMethodC = "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new NotImplementedException();\r\n    }",
                            DynamicMethodCJava = "\r\n    @Override\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new UnsupportedOperationException(\"Not implemented yet\");\r\n    }",
                            DynamicMethodI = "#TYPE# #NAME# (#PARAMS#);\n    ",
                            DynamicMethodIJava = "#TYPE# #NAME# (#PARAMS#);\n    ",
                            DynamicsCode = "#splitfile#\r\npublic class #C# : #AC1#\r\n{\r\n    #F;#C#\r\n\r\n    #M;#C#\r\n    public #C#(#I1# component) : base(component)\r\n    {\r\n    }\r\n\r\n    public override void Operation()\r\n    {\r\n        base.Operation();\r\n        AddedBehavior();\r\n    }\r\n\r\n    private void AddedBehavior()\r\n    {\r\n        Console.WriteLine(\"Added behavior by ConcreteDecorator\");\r\n    }\r\n}\r\n",
                            DynamicsCodeJava = "#splitfile#\r\npublic class #C# extends #AC1# {\r\n    #F;#C#\r\n	\r\n    #M;#C#\r\n    public #C#(#I1# component) {\r\n        super(component);\r\n    }\r\n\r\n    @Override\r\n    public void Operation() {\r\n        super.Operation();\r\n        AddedBehavior();\r\n    }\r\n\r\n    private void AddedBehavior() {\r\n        System.out.println(\"Added behavior by ConcreteDecorator\");\r\n    }\r\n}",
                            Name = "Decorator",
                            Schema = "#splitfile#\r\npublic interface #I1#\r\n{\r\n    #F;#I1#\r\n\r\n    #M;#I1#\r\n    void Operation();\r\n}\r\n#splitfile#\r\npublic class #CC1# : #I1#\r\n{\r\n    #F;#CC1#\r\n\r\n    #M;#CC1#\r\n    public void Operation()\r\n    {\r\n        Console.WriteLine(\"ConcreteComponent operation\");\r\n    }\r\n}\r\n#splitfile#\r\npublic abstract class #AC1# : #I1#\r\n{\r\n    protected #I1# component;\r\n    #F;#AC1#\r\n\r\n    #M;#AC1#\r\n    public #AC1#(#I1# component)\r\n    {\r\n        this.component = component;\r\n    }\r\n\r\n    public virtual void Operation()\r\n    {\r\n        component.Operation();\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\npublic class Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        #I1# component = new #CC1#();\r\n        #I1# decoratedComponent = new #C2#(component);\r\n\r\n        decoratedComponent.Operation();\r\n    }\r\n}",
                            SchemaJava = "#splitfile#\r\npublic interface #I1# {\r\n    #F;#I1#\r\n	\r\n    #M;#I1#\r\n    void Operation();\r\n}\r\n#splitfile#\r\npublic class #CC1# implements #I1# {\r\n    #F;#CC1#\r\n	\r\n    #M;#CC1#\r\n    @Override\r\n    public void Operation() {\r\n        System.out.println(\"ConcreteComponent operation\");\r\n    }\r\n}\r\n#splitfile#\r\npublic abstract class #AC1# implements #I1# {\r\n    protected #I1# component;\r\n    #F;#AC1#\r\n	\r\n    #M;#AC1#\r\n    public #AC1#(#I1# component) {\r\n        this.component = component;\r\n    }\r\n\r\n    @Override\r\n    public void Operation() {\r\n        component.Operation();\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\npublic class Program {\r\n    public static void main(String[] args) {\r\n        #I1# component = new #CC1#();\r\n        #I1# decoratedComponent = new #C2#(component);\r\n\r\n        decoratedComponent.Operation();\r\n    }\r\n}",
                            ToInterpret = "#I1#FajnyInterfejs# #CC1#Klasa# #AC1#AbstrakcyjnaKlasa# #C2#KlasaDekoratora# ",
                            Type = "Structural"
                        },
                        new
                        {
                            Id = new Guid("6706a7fc-0d05-4484-a9eb-54d4a47723a1"),
                            Description = "The Facade pattern provides a unified interface to a set of interfaces in a subsystem.",
                            DynamicMethodAC = "",
                            DynamicMethodACJava = "",
                            DynamicMethodC = "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new NotImplementedException();\r\n    }",
                            DynamicMethodCJava = "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new UnsupportedOperationException(\"Not implemented yet\");\r\n    }",
                            DynamicMethodI = "",
                            DynamicMethodIJava = "",
                            DynamicsCode = "#splitfile#\r\npublic class #C#\r\n{\r\n    #F;#C#\r\n\r\n	#M;#C#\r\n}",
                            DynamicsCodeJava = "#splitfile#\r\npublic class #C# {\r\n    #F;#C#\r\n\r\n    #M;#C#\r\n}",
                            Name = "Facade",
                            Schema = "#splitfile#\r\npublic class #CC1#\r\n{\r\n    private #CC2# flightBooking;\r\n    private #CC3# hotelBooking;\r\n    private #CC4# carRental;\r\n	#F;#CC1#\r\n\r\n	#M;#CC1#\r\n    public #CC1#()\r\n    {\r\n        flightBooking = new #CC2#();\r\n        hotelBooking = new #CC3#();\r\n        carRental = new #CC4#();\r\n    }\r\n\r\n    public void BookCompleteTrip(string departure, string destination, string hotelName, string carType)\r\n    {\r\n        Console.WriteLine(\"Booking complete trip...\");\r\n        flightBooking.BookFlight(departure, destination);\r\n        hotelBooking.BookHotel(hotelName);\r\n        carRental.RentCar(carType);\r\n        Console.WriteLine(\"Trip booking completed.\");\r\n    }\r\n	\r\n	public void BookInCompleteTrip(string departure, string destination, string hotelName)\r\n    {\r\n        Console.WriteLine(\"Booking complete trip...\");\r\n        flightBooking.BookFlight(departure, destination);\r\n        hotelBooking.BookHotel(hotelName);\r\n        Console.WriteLine(\"Trip booking without car rental completed.\");\r\n    }\r\n}\r\n#splitfile#\r\npublic class #CC2#\r\n{\r\n	#F;#CC2#\r\n\r\n	#M;#CC2#\r\n    public void BookFlight(string departure, string destination)\r\n    {\r\n        Console.WriteLine($\"Flight booked from {departure} to {destination}\");\r\n    }\r\n}\r\n#splitfile#\r\npublic class #CC3#\r\n{\r\n	#F;#CC3#\r\n\r\n	#M;#CC3#\r\n    public void BookHotel(string hotelName)\r\n    {\r\n        Console.WriteLine($\"Hotel booked: {hotelName}\");\r\n    }\r\n}\r\n#splitfile#\r\npublic class #CC4#\r\n{\r\n	#F;#CC4#\r\n\r\n	#M;#CC4#\r\n    public void RentCar(string carType)\r\n    {\r\n        Console.WriteLine($\"Car rented: {carType}\");\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        #CC1# travelFacade = new #CC1#();\r\n        \r\n        travelFacade.BookCompleteTrip(\"New York\", \"Los Angeles\", \"The Ritz-Carlton\", \"SUV\");\r\n        travelFacade.BookInCompleteTrip(\"New York\", \"Los Angeles\", \"The Ritz-Carlton\");\r\n        \r\n    }\r\n}",
                            SchemaJava = "#splitfile#\r\npublic class #CC1# {\r\n    private #CC2# flightBooking;\r\n    private #CC3# hotelBooking;\r\n    private #CC4# carRental;\r\n    #F;#CC1#\r\n\r\n    #M;#CC1#\r\n    public #CC1#() {\r\n        flightBooking = new #CC2#();\r\n        hotelBooking = new #CC3#();\r\n        carRental = new #CC4#();\r\n    }\r\n\r\n    public void BookCompleteTrip(String departure, String destination, String hotelName, String carType) {\r\n        System.out.println(\"Booking complete trip...\");\r\n        flightBooking.BookFlight(departure, destination);\r\n        hotelBooking.BookHotel(hotelName);\r\n        carRental.RentCar(carType);\r\n        System.out.println(\"Trip booking completed.\");\r\n    }\r\n\r\n    public void BookInCompleteTrip(String departure, String destination, String hotelName) {\r\n        System.out.println(\"Booking complete trip...\");\r\n        flightBooking.BookFlight(departure, destination);\r\n        hotelBooking.BookHotel(hotelName);\r\n        System.out.println(\"Trip booking without car rental completed.\");\r\n    }\r\n}\r\n#splitfile#\r\npublic class #CC2# {\r\n    #F;#CC2#\r\n\r\n    #M;#CC2#\r\n    public void BookFlight(String departure, String destination) {\r\n        System.out.println(\"Flight booked from \" + departure + \" to \" + destination);\r\n    }\r\n}\r\n#splitfile#\r\npublic class #CC3# {\r\n    #F;#CC3#\r\n\r\n    #M;#CC3#\r\n    public void BookHotel(String hotelName) {\r\n        System.out.println(\"Hotel booked: \" + hotelName);\r\n    }\r\n}\r\n#splitfile#\r\npublic class #CC4# {\r\n    #F;#CC4#\r\n\r\n    #M;#CC4#\r\n    public void RentCar(String carType) {\r\n        System.out.println(\"Car rented: \" + carType);\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\npublic class Program {\r\n    public static void main(String[] args) {\r\n        #CC1# travelFacade = new #CC1#();\r\n        \r\n        travelFacade.BookCompleteTrip(\"New York\", \"Los Angeles\", \"The Ritz-Carlton\", \"SUV\");\r\n        travelFacade.BookInCompleteTrip(\"New York\", \"Los Angeles\", \"The Ritz-Carlton\");\r\n    }\r\n}",
                            ToInterpret = "#CC1#TravelFacade# #CC2#FlightBooking# #CC3#HotelBooking# #CC4#CarRental# ",
                            Type = "Structural"
                        },
                        new
                        {
                            Id = new Guid("6c2afb6f-bcc5-4d02-92ef-b7df12fd0fac"),
                            Description = "The Flyweight pattern minimizes memory usage and improves performance by sharing as much as possible with similar objects.",
                            DynamicMethodAC = "",
                            DynamicMethodACJava = "",
                            DynamicMethodC = "",
                            DynamicMethodCJava = "",
                            DynamicMethodI = "",
                            DynamicMethodIJava = "",
                            DynamicsCode = "",
                            DynamicsCodeJava = "",
                            Name = "Flyweight",
                            Schema = "",
                            SchemaJava = "",
                            ToInterpret = "",
                            Type = "Structural"
                        },
                        new
                        {
                            Id = new Guid("752a9281-8840-4d7b-8fd6-5da1b3eee655"),
                            Description = "The Proxy pattern provides a surrogate or placeholder for another object to control access to it.",
                            DynamicMethodAC = "",
                            DynamicMethodACJava = "",
                            DynamicMethodC = "",
                            DynamicMethodCJava = "",
                            DynamicMethodI = "",
                            DynamicMethodIJava = "",
                            DynamicsCode = "",
                            DynamicsCodeJava = "",
                            Name = "Proxy",
                            Schema = "",
                            SchemaJava = "",
                            ToInterpret = "",
                            Type = "Structural"
                        },
                        new
                        {
                            Id = new Guid("bfdf0acd-cb53-4f6d-8502-5369af29c23f"),
                            Description = "The Factory Method pattern defines an interface for creating objects, but allows subclasses to alter the type of objects that will be created.",
                            DynamicMethodAC = "",
                            DynamicMethodACJava = "",
                            DynamicMethodC = "",
                            DynamicMethodCJava = "",
                            DynamicMethodI = "",
                            DynamicMethodIJava = "",
                            DynamicsCode = "",
                            DynamicsCodeJava = "",
                            Name = "Factory Method",
                            Schema = "",
                            SchemaJava = "",
                            ToInterpret = "",
                            Type = "Creational"
                        },
                        new
                        {
                            Id = new Guid("d5842261-670b-4896-8697-4e4c263cd86f"),
                            Description = "The Abstract Factory pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes.",
                            DynamicMethodAC = "",
                            DynamicMethodACJava = "",
                            DynamicMethodC = "",
                            DynamicMethodCJava = "",
                            DynamicMethodI = "",
                            DynamicMethodIJava = "",
                            DynamicsCode = "",
                            DynamicsCodeJava = "",
                            Name = "Abstract Factory",
                            Schema = "",
                            SchemaJava = "",
                            ToInterpret = "",
                            Type = "Creational"
                        },
                        new
                        {
                            Id = new Guid("da697d34-84c0-476a-a083-6e8b00209367"),
                            Description = "The Builder pattern separates the construction of a complex object from its representation, allowing the same construction process to create different representations.",
                            DynamicMethodAC = "\r\n    public virtual #TYPE# #NAME#(#PARAMS#){\r\n        component.#NAME#(#NOTYPEPARAMS#);\r\n    }",
                            DynamicMethodACJava = "\r\n    @Override\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        component.#NAME#(#NOTYPEPARAMS#);\r\n    }",
                            DynamicMethodC = "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new NotImplementedException();\r\n    }",
                            DynamicMethodCJava = "\r\n    @Override\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new UnsupportedOperationException(\"Not implemented yet\");\r\n    }",
                            DynamicMethodI = "#TYPE# #NAME# (#PARAMS#);\n    ",
                            DynamicMethodIJava = "#TYPE# #NAME# (#PARAMS#);\n    ",
                            DynamicsCode = "#splitfile#\r\npublic class #C#\r\n    {\r\n        private #I1# _builder;\r\n        #F;#C#\r\n\r\n		#M;#C#\r\n        public #I1# Builder\r\n        {\r\n            set { _builder = value; } \r\n        }\r\n        \r\n        public void BuildMinimalViableProduct()\r\n        {\r\n            this._builder.BuildPartA();\r\n        }\r\n        \r\n        public void BuildFullFeaturedProduct()\r\n        {\r\n            this._builder.BuildPartA();\r\n            this._builder.BuildPartB();\r\n        }\r\n    }",
                            DynamicsCodeJava = "#splitfile#\r\npublic class #C# {\r\n    private #I1# builder;\r\n    #F;#C#\r\n	\r\n    #M;#C#\r\n    public void setBuilder(#I1# builder) {\r\n        this.builder = builder;\r\n    }\r\n\r\n    public void BuildMinimalViableProduct() {\r\n        this.builder.BuildPartA();\r\n    }\r\n\r\n    public void BuildFullFeaturedProduct() {\r\n        this.builder.BuildPartA();\r\n        this.builder.BuildPartB();\r\n    }\r\n}",
                            Name = "Builder",
                            Schema = "#splitfile#\r\npublic interface #I1#\r\n    {\r\n	    #F;#I1#\r\n\r\n	    #M;#I1#\r\n        void BuildPartA();\r\n        \r\n        void BuildPartB();\r\n    }\r\n#splitfile#	\r\npublic class #CC1# : #I1#\r\n    {\r\n        private #CC2# _product = new #CC2#();\r\n        #F;#CC1#\r\n\r\n		#M;#CC1#\r\n        public #CC1#()\r\n        {\r\n            this.Reset();\r\n        }\r\n        \r\n        public void Reset()\r\n        {\r\n            this._product = new #CC2#();\r\n        }\r\n        \r\n        public void BuildPartA()\r\n        {\r\n            this._product.Add(\"PartA1\");\r\n        }\r\n        \r\n        public void BuildPartB()\r\n        {\r\n            this._product.Add(\"PartB1\");\r\n        }\r\n        \r\n        public #CC2# GetProduct()\r\n        {\r\n            #CC2# result = this._product;\r\n\r\n            this.Reset();\r\n\r\n            return result;\r\n        }\r\n    }\r\n#splitfile#\r\npublic class #CC2#\r\n    {\r\n        private List<string> _parts = new List<string>();\r\n        #F;#CC2#\r\n\r\n		#M;#CC2#\r\n        public void Add(string part)\r\n        {\r\n            this._parts.Add(part);\r\n        }\r\n        \r\n        public string ListParts()\r\n        {\r\n            string str = string.Empty;\r\n\r\n            for (int i = 0; i < this._parts.Count; i++)\r\n            {\r\n                str += this._parts[i] + \", \";\r\n            }\r\n\r\n            str = str.Remove(str.Length - 2);\r\n\r\n            return \"Product parts: \" + str + \"\\n\";\r\n        }\r\n    }\r\n#DYNAMICS#\r\n#splitfile#\r\nclass Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            var director = new #C#();\r\n            var builder = new #CC1#();\r\n            director.Builder = builder;\r\n            \r\n            Console.WriteLine(\"Standard basic product:\");\r\n            director.BuildMinimalViableProduct();\r\n            Console.WriteLine(builder.GetProduct().ListParts());\r\n\r\n            Console.WriteLine(\"Standard full featured product:\");\r\n            director.BuildFullFeaturedProduct();\r\n            Console.WriteLine(builder.GetProduct().ListParts());\r\n\r\n            Console.WriteLine(\"Custom product:\");\r\n            builder.BuildPartA();\r\n            Console.Write(builder.GetProduct().ListParts());\r\n        }\r\n    }",
                            SchemaJava = "#splitfile#\r\npublic interface #I1# {\r\n    #F;#I1#\r\n	\r\n    #M;#I1#\r\n    void BuildPartA();\r\n    void BuildPartB();\r\n}\r\n#splitfile#\r\npublic class #CC1# implements #I1# {\r\n    private #CC2# product = new #CC2#();\r\n    #F;#CC1#\r\n	\r\n    #M;#CC1#\r\n    public #CC1#() {\r\n        this.Reset();\r\n    }\r\n\r\n    public void Reset() {\r\n        this.product = new #CC2#();\r\n    }\r\n\r\n    @Override\r\n    public void BuildPartA() {\r\n        this.product.Add(\"PartA1\");\r\n    }\r\n\r\n    @Override\r\n    public void BuildPartB() {\r\n        this.product.Add(\"PartB1\");\r\n    }\r\n\r\n    public #CC2# GetProduct() {\r\n        #CC2# result = this.product;\r\n        this.Reset();\r\n        return result;\r\n    }\r\n}\r\n#splitfile#\r\npublic class #CC2# {\r\n    private List<String> parts = new ArrayList<>();\r\n	#F;#CC2#\r\n	\r\n    #M;#CC2#\r\n    public void Add(String part) {\r\n        this.parts.add(part);\r\n    }\r\n\r\n    public String ListParts() {\r\n        StringBuilder str = new StringBuilder();\r\n\r\n        for (int i = 0; i < this.parts.size(); i++) {\r\n            str.append(this.parts.get(i)).append(\", \");\r\n        }\r\n\r\n        if (str.length() > 0) {\r\n            str.setLength(str.length() - 2);\r\n        }\r\n\r\n        return \"Product parts: \" + str + \"\\n\";\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\npublic class Program {\r\n    public static void main(String[] args) {\r\n        #C# director = new #C#();\r\n        #CC1# builder = new #CC1#();\r\n        director.setBuilder(builder);\r\n\r\n        System.out.println(\"Standard basic product:\");\r\n        director.BuildMinimalViableProduct();\r\n        System.out.println(builder.GetProduct().ListParts());\r\n\r\n        System.out.println(\"Standard full featured product:\");\r\n        director.BuildFullFeaturedProduct();\r\n        System.out.println(builder.GetProduct().ListParts());\r\n\r\n        System.out.println(\"Custom product:\");\r\n        builder.BuildPartA();\r\n        System.out.print(builder.GetProduct().ListParts());\r\n    }\r\n}",
                            ToInterpret = "#I1#Interfejs# #CC1#FajnaKlasa# #CC2#Produkt# #C1#KonkretnyBuilder# ",
                            Type = "Creational"
                        },
                        new
                        {
                            Id = new Guid("f83fc61f-16b4-4160-9116-12d7c8c0c734"),
                            Description = "The Prototype pattern creates new objects by copying an existing object, known as the prototype.",
                            DynamicMethodAC = "",
                            DynamicMethodACJava = "",
                            DynamicMethodC = "",
                            DynamicMethodCJava = "",
                            DynamicMethodI = "",
                            DynamicMethodIJava = "",
                            DynamicsCode = "",
                            DynamicsCodeJava = "",
                            Name = "Prototype",
                            Schema = "",
                            SchemaJava = "",
                            ToInterpret = "",
                            Type = "Creational"
                        },
                        new
                        {
                            Id = new Guid("ffb8c2cb-3b24-4bbe-b4bd-35061073ee98"),
                            Description = "The Singleton pattern ensures that a class has only one instance and provides a global point of access to that instance.",
                            DynamicMethodAC = "",
                            DynamicMethodACJava = "",
                            DynamicMethodC = "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new NotImplementedException();\r\n    }",
                            DynamicMethodCJava = "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new UnsupportedOperationException(\"Not implemented yet\");\r\n    }",
                            DynamicMethodI = "",
                            DynamicMethodIJava = "",
                            DynamicsCode = "#splitfile#\r\npublic sealed class #C#\r\n{ \r\n	private static #C# _instance;\r\n	#F;#C#\r\n\r\n	#M;#C#\r\n    private #C#() { }\r\n	\r\n    public static #C# GetInstance()\r\n    {\r\n        if (_instance == null)\r\n        {\r\n            _instance = new #C#();\r\n        }\r\n        return _instance;\r\n    }\r\n}",
                            DynamicsCodeJava = "#splitfile#\r\npublic final class #C# {\r\n    private static #C# _instance;\r\n    #F;#C#\r\n\r\n    #M;#C#\r\n    private #C#() { }\r\n    \r\n    public static synchronized #C# GetInstance() {\r\n        if (_instance == null) {\r\n            _instance = new #C#();\r\n        }\r\n        return _instance;\r\n    }\r\n}",
                            Name = "Singleton",
                            Schema = "#splitfile#\r\npublic sealed class #CC1#\r\n{ \r\n	private static #CC1# _instance;\r\n	#F;#CC1#\r\n\r\n	#M;#CC1#\r\n    private #CC1#() { }\r\n	\r\n    public static #CC1# GetInstance()\r\n    {\r\n        if (_instance == null)\r\n        {\r\n            _instance = new #CC1#();\r\n        }\r\n        return _instance;\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        #CC1# s1 = #CC1#.GetInstance();\r\n        #CC1# s2 = #CC1#.GetInstance();\r\n    }\r\n}",
                            SchemaJava = "#splitfile#\r\npublic final class #CC1# {\r\n    private static #CC1# _instance;\r\n    #F;#CC1#\r\n\r\n    #M;#CC1#\r\n    private #CC1#() { }\r\n    \r\n    public static synchronized #CC1# GetInstance() {\r\n        if (_instance == null) {\r\n            _instance = new #CC1#();\r\n        }\r\n        return _instance;\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\npublic class Program {\r\n    public static void main(String[] args) {\r\n        #CC1# s1 = #CC1#.GetInstance();\r\n        #CC1# s2 = #CC1#.GetInstance();\r\n    }\r\n}",
                            ToInterpret = "#CC1#Singleton# ",
                            Type = "Creational"
                        },
                        new
                        {
                            Id = new Guid("ffb8c2cb-3b24-4bbe-b4bd-34061073ee98"),
                            Description = "Observer is a behavioral design pattern that lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they’re observing.",
                            DynamicMethodAC = "\r\n    public virtual #TYPE# #NAME#(#PARAMS#){\r\n        component.#NAME#(#NOTYPEPARAMS#);\r\n    }",
                            DynamicMethodACJava = "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new UnsupportedOperationException(\"Not implemented yet\");\r\n    }",
                            DynamicMethodC = "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new NotImplementedException();\r\n    }",
                            DynamicMethodCJava = "\r\n    @Override\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new UnsupportedOperationException(\"Not implemented yet\");\r\n    }",
                            DynamicMethodI = "#TYPE# #NAME# (#PARAMS#);\n    ",
                            DynamicMethodIJava = "#TYPE# #NAME# (#PARAMS#);\n    ",
                            DynamicsCode = "#splitfile#\r\nclass #C# : #I1#\r\n{\r\n    private int _state;\r\n    #F;#C#\r\n\r\n	#M;#C#\r\n    public void UpdateState()\r\n    {\r\n        _state++;\r\n        NotifyObservers();\r\n    }\r\n\r\n    public int GetState()\r\n    {\r\n        return _state;\r\n    }\r\n}",
                            DynamicsCodeJava = "#splitfile#\r\npublic class #C# extends #AC1# {\r\n    private int state;\r\n	#F;#C#\r\n\r\n	#M;#C#\r\n    public void updateState() {\r\n        state++;\r\n        notifyObservers();\r\n    }\r\n\r\n    public int getState() {\r\n        return state;\r\n    }\r\n}",
                            Name = "Observer",
                            Schema = "#splitfile#\r\npublic interface #I1#\r\n{\r\n	#F;#I1#\r\n\r\n	#M;#I1#\r\n    void Update();\r\n}\r\n#splitfile#\r\npublic class #CC1# : #I1#\r\n{\r\n    private #CC2# _observable;\r\n    private int _state;\r\n    #F;#CC1#\r\n\r\n	#M;#CC1#\r\n    public #CC1#(#CC2# observable)\r\n    {\r\n        _observable = observable;\r\n    }\r\n\r\n    public void Update()\r\n    {\r\n        _state = _observable.GetState();\r\n        Console.WriteLine(\"new state = \" + _state);\r\n    }\r\n}\r\n#splitfile#\r\npublic abstract class #AC1#\r\n{\r\n	\r\n    private List<#I1#> _observers = new List<#I1#>();\r\n    #F;#AC1#\r\n\r\n	#M;#AC1#\r\n    public void AddObserver(#I1# observer)\r\n    {\r\n        _observers.Add(observer);\r\n    }\r\n\r\n    public void RemoveObserver(#I1# observer)\r\n    {\r\n        _observers.Remove(observer);\r\n    }\r\n\r\n    public void NotifyObservers(object obj)\r\n    {\r\n        foreach (#I1# observer in _observers)\r\n        {\r\n            observer.Update();\r\n        }\r\n    }\r\n}\r\n#splitfile#\r\npublic class #CC2# : #I1#\r\n{\r\n    private int _state;\r\n    #F;#CC2#\r\n\r\n	#M;#CC2#\r\n    public void UpdateState()\r\n    {\r\n        _state++;\r\n        NotifyObservers();\r\n    }\r\n\r\n    public int GetState()\r\n    {\r\n        return _state;\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\npublic class Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        #CC2# observable = new #CC2#();\r\n        #I1# observer = new ObserverImpl(observable);\r\n        observable.AddObserver(observer);\r\n\r\n        observable.UpdateState();\r\n        observable.UpdateState();\r\n    }\r\n}",
                            SchemaJava = "#splitfile#\r\npublic interface #I1# {\r\n	#F;#I1#\r\n	\r\n	#M;#I1#\r\n    void Update();\r\n}\r\n#splitfile#\r\npublic class #CC1# implements #I1# {\r\n    private #CC2# observable;\r\n    private int state;\r\n	#F;#CC1#\r\n\r\n	#M;#CC1#\r\n    public #CC1#(#CC2# observable) {\r\n        this.observable = observable;\r\n    }\r\n\r\n    @Override\r\n    public void Update() {\r\n        state = observable.getState();\r\n        System.out.println(\"new state = \" + state);\r\n    }\r\n}\r\n#splitfile#\r\npublic abstract class #AC1# {\r\n    private List<#I1#> observers = new ArrayList<>();\r\n	#F;#AC1#\r\n\r\n	#M;#AC1#\r\n    public void addObserver(#I1# observer) {\r\n        observers.add(observer);\r\n    }\r\n\r\n    public void removeObserver(#I1# observer) {\r\n        observers.remove(observer);\r\n    }\r\n\r\n    public void notifyObservers() {\r\n        for (#I1# observer : observers) {\r\n            observer.Update();\r\n        }\r\n    }\r\n}\r\n#splitfile#\r\npublic class #CC2# extends #AC1# {\r\n    private int state;\r\n	#F;#CC2#\r\n	\r\n	#M;#CC2#\r\n    public void updateState() {\r\n        state++;\r\n        notifyObservers();\r\n    }\r\n\r\n    public int getState() {\r\n        return state;\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\npublic class Program {\r\n    public static void main(String[] args) {\r\n        #CC2# observable = new #CC2#();\r\n        #I1# observer = new #CC1#(observable);\r\n        observable.addObserver(observer);\r\n\r\n        observable.updateState();\r\n        observable.updateState();\r\n    }\r\n}",
                            ToInterpret = "#I1#Interfejs# #CC1#Obserwator# #AC1#Abstrakcyjnaklasa# #CC2#ObserwatorImpl# ",
                            Type = "Behavioral"
                        },
                        new
                        {
                            Id = new Guid("ffb8c2cb-3b34-4bbe-b4bd-35061073ee98"),
                            Description = "Chain of Responsibility is a behavioral design pattern that lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.",
                            DynamicMethodAC = "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new NotImplementedException();\r\n    }",
                            DynamicMethodACJava = "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new UnsupportedOperationException(\"Not implemented yet\");\r\n    }",
                            DynamicMethodC = "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new NotImplementedException();\r\n    }",
                            DynamicMethodCJava = "\r\n    @Override\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new UnsupportedOperationException(\"Not implemented yet\");\r\n    }",
                            DynamicMethodI = "#TYPE# #NAME# (#PARAMS#);\n    ",
                            DynamicMethodIJava = "#TYPE# #NAME# (#PARAMS#);\n    ",
                            DynamicsCode = "#splitfile#\r\nclass #C# : #AC1#\r\n{\r\n	#F;#C#\r\n\r\n	#M;#C#\r\n    public override object Handle(object request)\r\n    {\r\n        if (request.ToString() == \"Cup of coffee\") //change in your code\r\n        {\r\n			Console.Write($\"NewHandler: I'll eat the {request.ToString()}.\\n\");\r\n            return \"\";\r\n        }\r\n        else\r\n        {\r\n			Console.Write($\"NewHandler: I'm hungry!\\n\");\r\n            return base.Handle(request);\r\n        }\r\n    }\r\n}",
                            DynamicsCodeJava = "#splitfile#\r\nclass #C# extends #AC1# {\r\n    #F;#C#\r\n\r\n    #M;#C#\r\n    @Override\r\n    public Object Handle(Object request) {\r\n        if (request.toString().equals(\"Cup of coffee\")) {\r\n            System.out.print(\"NewHandler: I'll drink the \" + request.toString() + \".\\n\");\r\n            return \"\";\r\n        } else {\r\n            System.out.print(\"NewHandler: I'm thirsty!\\n\");\r\n            return super.Handle(request);\r\n        }\r\n    }\r\n}",
                            Name = "Chain of Responsibility",
                            Schema = "#splitfile#\r\npublic interface #I1#\r\n{\r\n	#F;#I1#\r\n\r\n	#M;#I1#\r\n    #I1# SetNext(#I1# handler);\r\n    \r\n    object Handle(object request);\r\n}\r\n#splitfile#\r\nabstract class #AC1# : #I1#\r\n{\r\n    private #I1# _nextHandler;\r\n	#F;#AC1#\r\n\r\n	#M;#AC1#\r\n    public #I1# SetNext(#I1# handler)\r\n    {\r\n        this._nextHandler = handler;\r\n        \r\n        return handler;\r\n    }\r\n    \r\n    public virtual object Handle(object request)\r\n    {\r\n        if (this._nextHandler != null)\r\n        {\r\n            return this._nextHandler.Handle(request);\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n#splitfile#\r\nclass #CC1# : #AC1#\r\n{\r\n	#F;#CC1#\r\n\r\n	#M;#CC1#\r\n    public override object Handle(object request)\r\n    {\r\n        if ((request as string) == \"Pizza\")\r\n        {\r\n			Console.Write($\"Johny: I'll eat the {request.ToString()}.\\n\");\r\n            return \"\";\r\n        }\r\n        else\r\n        {\r\n			Console.Write($\"Johny: I'm hungry!\\n\");\r\n            return base.Handle(request);\r\n        }\r\n    }\r\n}\r\n#splitfile#\r\nclass #CC2# : #AC1#\r\n{\r\n	#F;#CC2#\r\n\r\n	#M;#CC2#\r\n    public override object Handle(object request)\r\n    {\r\n        if (request.ToString() == \"Donut\")\r\n        {\r\n			Console.Write($\"Arthur: I'll eat the {request.ToString()}.\\n\");\r\n            return \"\";\r\n        }\r\n        else\r\n        {\r\n			Console.Write($\"Arthur: I'm hungry!\\n\");\r\n            return base.Handle(request);\r\n        }\r\n    }\r\n}\r\n#splitfile#\r\nclass #CC3# : #AC1#\r\n{\r\n	#F;#CC3#\r\n\r\n	#M;#CC3#\r\n    public override object Handle(object request)\r\n    {\r\n        if (request.ToString() == \"Kebab\")\r\n        {\r\n			Console.Write($\"Tadeusz: I'll eat the {request.ToString()}.\\n\");\r\n            return \"\";\r\n        }\r\n        else\r\n        {\r\n			Console.Write($\"Tadeusz: I'm hungry!\\n\");\r\n            return base.Handle(request);\r\n        }\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        var handler1 = new #CC1#();\r\n        var handler2 = new #CC2#();\r\n        var handler3 = new #CC3#();\r\n\r\n        handler1.SetNext(handler2).SetNext(handler3);\r\n\r\n        foreach (var food in new List<string> { \"Pizza\", \"Kebab\", \"Cup of coffee\", \"Donut\" })\r\n        {\r\n            Console.WriteLine($\"Chef: Who wants a {food}?\");\r\n\r\n            var result = handler1.Handle(food);\r\n\r\n            if (result == null)\r\n            {\r\n                Console.WriteLine($\"   {food} was left untouched.\");\r\n            }\r\n        }\r\n    }\r\n}",
                            SchemaJava = "#splitfile#\r\npublic interface #I1# {\r\n    #F;#I1#\r\n\r\n    #M;#I1#\r\n    #I1# SetNext(#I1# handler);\r\n    \r\n    Object Handle(Object request);\r\n}\r\n#splitfile#\r\nabstract class #AC1# implements #I1# {\r\n    private #I1# _nextHandler;\r\n    #F;#AC1#\r\n\r\n    #M;#AC1#\r\n    public #I1# SetNext(#I1# handler) {\r\n        this._nextHandler = handler;\r\n        \r\n        return handler;\r\n    }\r\n    \r\n    public Object Handle(Object request) {\r\n        if (this._nextHandler != null) {\r\n            return this._nextHandler.Handle(request);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n#splitfile#\r\nclass #CC1# extends #AC1# {\r\n    #F;#CC1#\r\n\r\n    #M;#CC1#\r\n    @Override\r\n    public Object Handle(Object request) {\r\n        if (request.toString().equals(\"Pizza\")) {\r\n            System.out.print(\"Johny: I'll eat the \" + request.toString() + \".\\n\");\r\n            return \"\";\r\n        } else {\r\n            System.out.print(\"Johny: I'm hungry!\\n\");\r\n            return super.Handle(request);\r\n        }\r\n    }\r\n}\r\n#splitfile#\r\nclass #CC2# extends #AC1# {\r\n    #F;#CC2#\r\n\r\n    #M;#CC2#\r\n    @Override\r\n    public Object Handle(Object request) {\r\n        if (request.toString().equals(\"Donut\")) {\r\n            System.out.print(\"Arthur: I'll eat the \" + request.toString() + \".\\n\");\r\n            return \"\";\r\n        } else {\r\n            System.out.print(\"Arthur: I'm hungry!\\n\");\r\n            return super.Handle(request);\r\n        }\r\n    }\r\n}\r\n#splitfile#\r\nclass #CC3# extends #AC1# {\r\n    #F;#CC3#\r\n\r\n    #M;#CC3#\r\n    @Override\r\n    public Object Handle(Object request) {\r\n        if (request.toString().equals(\"Kebab\")) {\r\n            System.out.print(\"Tadeusz: I'll eat the \" + request.toString() + \".\\n\");\r\n            return \"\";\r\n        } else {\r\n            System.out.print(\"Tadeusz: I'm hungry!\\n\");\r\n            return super.Handle(request);\r\n        }\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\npublic class Program {\r\n    public static void main(String[] args) {\r\n        #CC1# handler1 = new #CC1#();\r\n        #CC2# handler2 = new #CC2#();\r\n        #CC3# handler3 = new #CC3#();\r\n\r\n        handler1.SetNext(handler2).SetNext(handler3);\r\n\r\n        List<String> foods = Arrays.asList(\"Pizza\", \"Kebab\", \"Cup of coffee\", \"Donut\");\r\n        for (String food : foods) {\r\n            System.out.println(\"Chef: Who wants a \" + food + \"?\");\r\n\r\n            Object result = handler1.Handle(food);\r\n\r\n            if (result == null) {\r\n                System.out.println(\"   \" + food + \" was left untouched.\");\r\n            }\r\n        }\r\n    }\r\n}",
                            ToInterpret = "#I1#IHandler# #AC1#AbstractHandler# #CC1#JohnyHandler# #CC2#ArthurHandler# #CC3#TadeuszHandler# ",
                            Type = "Behavioral"
                        });
                });
#pragma warning restore 612, 618
        }
    }
}
