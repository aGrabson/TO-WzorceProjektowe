using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace WzorceProjektowe.API.Migrations
{
    public partial class init : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Patterns",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uniqueidentifier", nullable: false),
                    Name = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Description = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Type = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    Schema = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    ToInterpret = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    DynamicsCode = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    SchemaJava = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    DynamicsCodeJava = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    DynamicMethodI = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    DynamicMethodC = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    DynamicMethodAC = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    DynamicMethodIJava = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    DynamicMethodCJava = table.Column<string>(type: "nvarchar(max)", nullable: false),
                    DynamicMethodACJava = table.Column<string>(type: "nvarchar(max)", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Patterns", x => x.Id);
                });

            migrationBuilder.InsertData(
                table: "Patterns",
                columns: new[] { "Id", "Description", "DynamicMethodAC", "DynamicMethodACJava", "DynamicMethodC", "DynamicMethodCJava", "DynamicMethodI", "DynamicMethodIJava", "DynamicsCode", "DynamicsCodeJava", "Name", "Schema", "SchemaJava", "ToInterpret", "Type" },
                values: new object[,]
                {
                    { new Guid("21ada38f-cd9b-4231-b564-d6c5f3412260"), "The Adapter pattern allows objects with incompatible interfaces to collaborate.", "", "", "", "", "", "", "", "", "Adapter", "interface ITarget {\r\n    void Request();\r\n}\r\n\r\nclass Adaptee {\r\n    public void SpecificRequest() {\r\n        Console.WriteLine(\"Specific request\");\r\n    }\r\n}\r\n\r\nclass Adapter : ITarget {\r\n    private Adaptee _adaptee;\r\n\r\n    public Adapter(Adaptee adaptee) {\r\n        _adaptee = adaptee;\r\n    }\r\n\r\n    public void Request() {\r\n        _adaptee.SpecificRequest();\r\n    }\r\n}\r\n\r\nclass Client {\r\n    static void Main(string[] args) {\r\n        Adaptee adaptee = new Adaptee();\r\n        ITarget adapter = new Adapter(adaptee);\r\n        adapter.Request();\r\n    }\r\n}", "", "", "Structural" },
                    { new Guid("249dbdc9-acc3-449d-8968-634c089e7ba1"), "The Bridge pattern decouples an abstraction from its implementation so that the two can vary independently.", "", "", "", "", "", "", "", "", "Bridge", "", "", "", "Structural" },
                    { new Guid("493b34a1-12e1-4967-aa6c-a54cd9d147f9"), "The Composite pattern composes objects into tree structures to represent part-whole hierarchies.", "", "", "", "", "", "", "", "", "Composite", "", "", "", "Structural" },
                    { new Guid("6469a535-507a-44fd-b9d7-dcf831847a21"), "The Decorator pattern attaches additional responsibilities to objects dynamically.", "\r\n    public virtual #TYPE# #NAME#(#PARAMS#){\r\n        component.#NAME#(#NOTYPEPARAMS#);\r\n    }", "\r\n    @Override\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        component.#NAME#(#NOTYPEPARAMS#);\r\n    }", "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new NotImplementedException();\r\n    }", "\r\n    @Override\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new UnsupportedOperationException(\"Not implemented yet\");\r\n    }", "#TYPE# #NAME# (#PARAMS#);\n    ", "#TYPE# #NAME# (#PARAMS#);\n    ", "#splitfile#\r\npublic class #C# : #AC1#\r\n{\r\n    #F;#C#\r\n\r\n    #M;#C#\r\n    public #C#(#I1# component) : base(component)\r\n    {\r\n    }\r\n\r\n    public override void Operation()\r\n    {\r\n        base.Operation();\r\n        AddedBehavior();\r\n    }\r\n\r\n    private void AddedBehavior()\r\n    {\r\n        Console.WriteLine(\"Added behavior by ConcreteDecorator\");\r\n    }\r\n}\r\n", "#splitfile#\r\npublic class #C# extends #AC1# {\r\n    #F;#C#\r\n	\r\n    #M;#C#\r\n    public #C#(#I1# component) {\r\n        super(component);\r\n    }\r\n\r\n    @Override\r\n    public void Operation() {\r\n        super.Operation();\r\n        AddedBehavior();\r\n    }\r\n\r\n    private void AddedBehavior() {\r\n        System.out.println(\"Added behavior by ConcreteDecorator\");\r\n    }\r\n}", "Decorator", "#splitfile#\r\npublic interface #I1#\r\n{\r\n    #F;#I1#\r\n\r\n    #M;#I1#\r\n    void Operation();\r\n}\r\n#splitfile#\r\npublic class #CC1# : #I1#\r\n{\r\n    #F;#CC1#\r\n\r\n    #M;#CC1#\r\n    public void Operation()\r\n    {\r\n        Console.WriteLine(\"ConcreteComponent operation\");\r\n    }\r\n}\r\n#splitfile#\r\npublic abstract class #AC1# : #I1#\r\n{\r\n    protected #I1# component;\r\n    #F;#AC1#\r\n\r\n    #M;#AC1#\r\n    public #AC1#(#I1# component)\r\n    {\r\n        this.component = component;\r\n    }\r\n\r\n    public virtual void Operation()\r\n    {\r\n        component.Operation();\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\npublic class Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        #I1# component = new #CC1#();\r\n        #I1# decoratedComponent = new #C2#(component);\r\n\r\n        decoratedComponent.Operation();\r\n    }\r\n}", "#splitfile#\r\npublic interface #I1# {\r\n    #F;#I1#\r\n	\r\n    #M;#I1#\r\n    void Operation();\r\n}\r\n#splitfile#\r\npublic class #CC1# implements #I1# {\r\n    #F;#CC1#\r\n	\r\n    #M;#CC1#\r\n    @Override\r\n    public void Operation() {\r\n        System.out.println(\"ConcreteComponent operation\");\r\n    }\r\n}\r\n#splitfile#\r\npublic abstract class #AC1# implements #I1# {\r\n    protected #I1# component;\r\n    #F;#AC1#\r\n	\r\n    #M;#AC1#\r\n    public #AC1#(#I1# component) {\r\n        this.component = component;\r\n    }\r\n\r\n    @Override\r\n    public void Operation() {\r\n        component.Operation();\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\npublic class Program {\r\n    public static void main(String[] args) {\r\n        #I1# component = new #CC1#();\r\n        #I1# decoratedComponent = new #C2#(component);\r\n\r\n        decoratedComponent.Operation();\r\n    }\r\n}", "#I1#FajnyInterfejs# #CC1#Klasa# #AC1#AbstrakcyjnaKlasa# #C2#KlasaDekoratora# ", "Structural" },
                    { new Guid("6706a7fc-0d05-4484-a9eb-54d4a47723a1"), "The Facade pattern provides a unified interface to a set of interfaces in a subsystem.", "", "", "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new NotImplementedException();\r\n    }", "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new UnsupportedOperationException(\"Not implemented yet\");\r\n    }", "", "", "#splitfile#\r\npublic class #C#\r\n{\r\n    #F;#C#\r\n\r\n	#M;#C#\r\n}", "#splitfile#\r\npublic class #C# {\r\n    #F;#C#\r\n\r\n    #M;#C#\r\n}", "Facade", "#splitfile#\r\npublic class #CC1#\r\n{\r\n    private #CC2# flightBooking;\r\n    private #CC3# hotelBooking;\r\n    private #CC4# carRental;\r\n	#F;#CC1#\r\n\r\n	#M;#CC1#\r\n    public #CC1#()\r\n    {\r\n        flightBooking = new #CC2#();\r\n        hotelBooking = new #CC3#();\r\n        carRental = new #CC4#();\r\n    }\r\n\r\n    public void BookCompleteTrip(string departure, string destination, string hotelName, string carType)\r\n    {\r\n        Console.WriteLine(\"Booking complete trip...\");\r\n        flightBooking.BookFlight(departure, destination);\r\n        hotelBooking.BookHotel(hotelName);\r\n        carRental.RentCar(carType);\r\n        Console.WriteLine(\"Trip booking completed.\");\r\n    }\r\n	\r\n	public void BookInCompleteTrip(string departure, string destination, string hotelName)\r\n    {\r\n        Console.WriteLine(\"Booking complete trip...\");\r\n        flightBooking.BookFlight(departure, destination);\r\n        hotelBooking.BookHotel(hotelName);\r\n        Console.WriteLine(\"Trip booking without car rental completed.\");\r\n    }\r\n}\r\n#splitfile#\r\npublic class #CC2#\r\n{\r\n	#F;#CC2#\r\n\r\n	#M;#CC2#\r\n    public void BookFlight(string departure, string destination)\r\n    {\r\n        Console.WriteLine($\"Flight booked from {departure} to {destination}\");\r\n    }\r\n}\r\n#splitfile#\r\npublic class #CC3#\r\n{\r\n	#F;#CC3#\r\n\r\n	#M;#CC3#\r\n    public void BookHotel(string hotelName)\r\n    {\r\n        Console.WriteLine($\"Hotel booked: {hotelName}\");\r\n    }\r\n}\r\n#splitfile#\r\npublic class #CC4#\r\n{\r\n	#F;#CC4#\r\n\r\n	#M;#CC4#\r\n    public void RentCar(string carType)\r\n    {\r\n        Console.WriteLine($\"Car rented: {carType}\");\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        #CC1# travelFacade = new #CC1#();\r\n        \r\n        travelFacade.BookCompleteTrip(\"New York\", \"Los Angeles\", \"The Ritz-Carlton\", \"SUV\");\r\n        travelFacade.BookInCompleteTrip(\"New York\", \"Los Angeles\", \"The Ritz-Carlton\");\r\n        \r\n    }\r\n}", "#splitfile#\r\npublic class #CC1# {\r\n    private #CC2# flightBooking;\r\n    private #CC3# hotelBooking;\r\n    private #CC4# carRental;\r\n    #F;#CC1#\r\n\r\n    #M;#CC1#\r\n    public #CC1#() {\r\n        flightBooking = new #CC2#();\r\n        hotelBooking = new #CC3#();\r\n        carRental = new #CC4#();\r\n    }\r\n\r\n    public void BookCompleteTrip(String departure, String destination, String hotelName, String carType) {\r\n        System.out.println(\"Booking complete trip...\");\r\n        flightBooking.BookFlight(departure, destination);\r\n        hotelBooking.BookHotel(hotelName);\r\n        carRental.RentCar(carType);\r\n        System.out.println(\"Trip booking completed.\");\r\n    }\r\n\r\n    public void BookInCompleteTrip(String departure, String destination, String hotelName) {\r\n        System.out.println(\"Booking complete trip...\");\r\n        flightBooking.BookFlight(departure, destination);\r\n        hotelBooking.BookHotel(hotelName);\r\n        System.out.println(\"Trip booking without car rental completed.\");\r\n    }\r\n}\r\n#splitfile#\r\npublic class #CC2# {\r\n    #F;#CC2#\r\n\r\n    #M;#CC2#\r\n    public void BookFlight(String departure, String destination) {\r\n        System.out.println(\"Flight booked from \" + departure + \" to \" + destination);\r\n    }\r\n}\r\n#splitfile#\r\npublic class #CC3# {\r\n    #F;#CC3#\r\n\r\n    #M;#CC3#\r\n    public void BookHotel(String hotelName) {\r\n        System.out.println(\"Hotel booked: \" + hotelName);\r\n    }\r\n}\r\n#splitfile#\r\npublic class #CC4# {\r\n    #F;#CC4#\r\n\r\n    #M;#CC4#\r\n    public void RentCar(String carType) {\r\n        System.out.println(\"Car rented: \" + carType);\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\npublic class Program {\r\n    public static void main(String[] args) {\r\n        #CC1# travelFacade = new #CC1#();\r\n        \r\n        travelFacade.BookCompleteTrip(\"New York\", \"Los Angeles\", \"The Ritz-Carlton\", \"SUV\");\r\n        travelFacade.BookInCompleteTrip(\"New York\", \"Los Angeles\", \"The Ritz-Carlton\");\r\n    }\r\n}", "#CC1#TravelFacade# #CC2#FlightBooking# #CC3#HotelBooking# #CC4#CarRental# ", "Structural" },
                    { new Guid("6c2afb6f-bcc5-4d02-92ef-b7df12fd0fac"), "The Flyweight pattern minimizes memory usage and improves performance by sharing as much as possible with similar objects.", "", "", "", "", "", "", "", "", "Flyweight", "", "", "", "Structural" },
                    { new Guid("752a9281-8840-4d7b-8fd6-5da1b3eee655"), "The Proxy pattern provides a surrogate or placeholder for another object to control access to it.", "", "", "", "", "", "", "", "", "Proxy", "", "", "", "Structural" },
                    { new Guid("bfdf0acd-cb53-4f6d-8502-5369af29c23f"), "The Factory Method pattern defines an interface for creating objects, but allows subclasses to alter the type of objects that will be created.", "", "", "", "", "", "", "", "", "Factory Method", "", "", "", "Creational" },
                    { new Guid("d5842261-670b-4896-8697-4e4c263cd86f"), "The Abstract Factory pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes.", "", "", "", "", "", "", "", "", "Abstract Factory", "", "", "", "Creational" },
                    { new Guid("da697d34-84c0-476a-a083-6e8b00209367"), "The Builder pattern separates the construction of a complex object from its representation, allowing the same construction process to create different representations.", "\r\n    public virtual #TYPE# #NAME#(#PARAMS#){\r\n        component.#NAME#(#NOTYPEPARAMS#);\r\n    }", "\r\n    @Override\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        component.#NAME#(#NOTYPEPARAMS#);\r\n    }", "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new NotImplementedException();\r\n    }", "\r\n    @Override\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new UnsupportedOperationException(\"Not implemented yet\");\r\n    }", "#TYPE# #NAME# (#PARAMS#);\n    ", "#TYPE# #NAME# (#PARAMS#);\n    ", "#splitfile#\r\npublic class #C#\r\n    {\r\n        private #I1# _builder;\r\n        #F;#C#\r\n\r\n		#M;#C#\r\n        public #I1# Builder\r\n        {\r\n            set { _builder = value; } \r\n        }\r\n        \r\n        public void BuildMinimalViableProduct()\r\n        {\r\n            this._builder.BuildPartA();\r\n        }\r\n        \r\n        public void BuildFullFeaturedProduct()\r\n        {\r\n            this._builder.BuildPartA();\r\n            this._builder.BuildPartB();\r\n        }\r\n    }", "#splitfile#\r\npublic class #C# {\r\n    private #I1# builder;\r\n    #F;#C#\r\n	\r\n    #M;#C#\r\n    public void setBuilder(#I1# builder) {\r\n        this.builder = builder;\r\n    }\r\n\r\n    public void BuildMinimalViableProduct() {\r\n        this.builder.BuildPartA();\r\n    }\r\n\r\n    public void BuildFullFeaturedProduct() {\r\n        this.builder.BuildPartA();\r\n        this.builder.BuildPartB();\r\n    }\r\n}", "Builder", "#splitfile#\r\npublic interface #I1#\r\n    {\r\n	    #F;#I1#\r\n\r\n	    #M;#I1#\r\n        void BuildPartA();\r\n        \r\n        void BuildPartB();\r\n    }\r\n#splitfile#	\r\npublic class #CC1# : #I1#\r\n    {\r\n        private #CC2# _product = new #CC2#();\r\n        #F;#CC1#\r\n\r\n		#M;#CC1#\r\n        public #CC1#()\r\n        {\r\n            this.Reset();\r\n        }\r\n        \r\n        public void Reset()\r\n        {\r\n            this._product = new #CC2#();\r\n        }\r\n        \r\n        public void BuildPartA()\r\n        {\r\n            this._product.Add(\"PartA1\");\r\n        }\r\n        \r\n        public void BuildPartB()\r\n        {\r\n            this._product.Add(\"PartB1\");\r\n        }\r\n        \r\n        public #CC2# GetProduct()\r\n        {\r\n            #CC2# result = this._product;\r\n\r\n            this.Reset();\r\n\r\n            return result;\r\n        }\r\n    }\r\n#splitfile#\r\npublic class #CC2#\r\n    {\r\n        private List<string> _parts = new List<string>();\r\n        #F;#CC2#\r\n\r\n		#M;#CC2#\r\n        public void Add(string part)\r\n        {\r\n            this._parts.Add(part);\r\n        }\r\n        \r\n        public string ListParts()\r\n        {\r\n            string str = string.Empty;\r\n\r\n            for (int i = 0; i < this._parts.Count; i++)\r\n            {\r\n                str += this._parts[i] + \", \";\r\n            }\r\n\r\n            str = str.Remove(str.Length - 2);\r\n\r\n            return \"Product parts: \" + str + \"\\n\";\r\n        }\r\n    }\r\n#DYNAMICS#\r\n#splitfile#\r\nclass Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            var director = new #C#();\r\n            var builder = new #CC1#();\r\n            director.Builder = builder;\r\n            \r\n            Console.WriteLine(\"Standard basic product:\");\r\n            director.BuildMinimalViableProduct();\r\n            Console.WriteLine(builder.GetProduct().ListParts());\r\n\r\n            Console.WriteLine(\"Standard full featured product:\");\r\n            director.BuildFullFeaturedProduct();\r\n            Console.WriteLine(builder.GetProduct().ListParts());\r\n\r\n            Console.WriteLine(\"Custom product:\");\r\n            builder.BuildPartA();\r\n            Console.Write(builder.GetProduct().ListParts());\r\n        }\r\n    }", "#splitfile#\r\npublic interface #I1# {\r\n    #F;#I1#\r\n	\r\n    #M;#I1#\r\n    void BuildPartA();\r\n    void BuildPartB();\r\n}\r\n#splitfile#\r\npublic class #CC1# implements #I1# {\r\n    private #CC2# product = new #CC2#();\r\n    #F;#CC1#\r\n	\r\n    #M;#CC1#\r\n    public #CC1#() {\r\n        this.Reset();\r\n    }\r\n\r\n    public void Reset() {\r\n        this.product = new #CC2#();\r\n    }\r\n\r\n    @Override\r\n    public void BuildPartA() {\r\n        this.product.Add(\"PartA1\");\r\n    }\r\n\r\n    @Override\r\n    public void BuildPartB() {\r\n        this.product.Add(\"PartB1\");\r\n    }\r\n\r\n    public #CC2# GetProduct() {\r\n        #CC2# result = this.product;\r\n        this.Reset();\r\n        return result;\r\n    }\r\n}\r\n#splitfile#\r\npublic class #CC2# {\r\n    private List<String> parts = new ArrayList<>();\r\n	#F;#CC2#\r\n	\r\n    #M;#CC2#\r\n    public void Add(String part) {\r\n        this.parts.add(part);\r\n    }\r\n\r\n    public String ListParts() {\r\n        StringBuilder str = new StringBuilder();\r\n\r\n        for (int i = 0; i < this.parts.size(); i++) {\r\n            str.append(this.parts.get(i)).append(\", \");\r\n        }\r\n\r\n        if (str.length() > 0) {\r\n            str.setLength(str.length() - 2);\r\n        }\r\n\r\n        return \"Product parts: \" + str + \"\\n\";\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\npublic class Program {\r\n    public static void main(String[] args) {\r\n        #C# director = new #C#();\r\n        #CC1# builder = new #CC1#();\r\n        director.setBuilder(builder);\r\n\r\n        System.out.println(\"Standard basic product:\");\r\n        director.BuildMinimalViableProduct();\r\n        System.out.println(builder.GetProduct().ListParts());\r\n\r\n        System.out.println(\"Standard full featured product:\");\r\n        director.BuildFullFeaturedProduct();\r\n        System.out.println(builder.GetProduct().ListParts());\r\n\r\n        System.out.println(\"Custom product:\");\r\n        builder.BuildPartA();\r\n        System.out.print(builder.GetProduct().ListParts());\r\n    }\r\n}", "#I1#Interfejs# #CC1#FajnaKlasa# #CC2#Produkt# #C1#KonkretnyBuilder# ", "Creational" },
                    { new Guid("f83fc61f-16b4-4160-9116-12d7c8c0c734"), "The Prototype pattern creates new objects by copying an existing object, known as the prototype.", "", "", "", "", "", "", "", "", "Prototype", "", "", "", "Creational" },
                    { new Guid("ffb8c2cb-3b24-4bbe-b4bd-34061073ee98"), "Observer is a behavioral design pattern that lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they’re observing.", "\r\n    public virtual #TYPE# #NAME#(#PARAMS#){\r\n        component.#NAME#(#NOTYPEPARAMS#);\r\n    }", "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new UnsupportedOperationException(\"Not implemented yet\");\r\n    }", "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new NotImplementedException();\r\n    }", "\r\n    @Override\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new UnsupportedOperationException(\"Not implemented yet\");\r\n    }", "#TYPE# #NAME# (#PARAMS#);\n    ", "#TYPE# #NAME# (#PARAMS#);\n    ", "#splitfile#\r\nclass #C# : #I1#\r\n{\r\n    private int _state;\r\n    #F;#C#\r\n\r\n	#M;#C#\r\n    public void UpdateState()\r\n    {\r\n        _state++;\r\n        NotifyObservers();\r\n    }\r\n\r\n    public int GetState()\r\n    {\r\n        return _state;\r\n    }\r\n}", "#splitfile#\r\npublic class #C# extends #AC1# {\r\n    private int state;\r\n	#F;#C#\r\n\r\n	#M;#C#\r\n    public void updateState() {\r\n        state++;\r\n        notifyObservers();\r\n    }\r\n\r\n    public int getState() {\r\n        return state;\r\n    }\r\n}", "Observer", "#splitfile#\r\npublic interface #I1#\r\n{\r\n	#F;#I1#\r\n\r\n	#M;#I1#\r\n    void Update();\r\n}\r\n#splitfile#\r\npublic class #CC1# : #I1#\r\n{\r\n    private #CC2# _observable;\r\n    private int _state;\r\n    #F;#CC1#\r\n\r\n	#M;#CC1#\r\n    public #CC1#(#CC2# observable)\r\n    {\r\n        _observable = observable;\r\n    }\r\n\r\n    public void Update()\r\n    {\r\n        _state = _observable.GetState();\r\n        Console.WriteLine(\"new state = \" + _state);\r\n    }\r\n}\r\n#splitfile#\r\npublic abstract class #AC1#\r\n{\r\n	\r\n    private List<#I1#> _observers = new List<#I1#>();\r\n    #F;#AC1#\r\n\r\n	#M;#AC1#\r\n    public void AddObserver(#I1# observer)\r\n    {\r\n        _observers.Add(observer);\r\n    }\r\n\r\n    public void RemoveObserver(#I1# observer)\r\n    {\r\n        _observers.Remove(observer);\r\n    }\r\n\r\n    public void NotifyObservers(object obj)\r\n    {\r\n        foreach (#I1# observer in _observers)\r\n        {\r\n            observer.Update();\r\n        }\r\n    }\r\n}\r\n#splitfile#\r\npublic class #CC2# : #I1#\r\n{\r\n    private int _state;\r\n    #F;#CC2#\r\n\r\n	#M;#CC2#\r\n    public void UpdateState()\r\n    {\r\n        _state++;\r\n        NotifyObservers();\r\n    }\r\n\r\n    public int GetState()\r\n    {\r\n        return _state;\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\npublic class Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        #CC2# observable = new #CC2#();\r\n        #I1# observer = new ObserverImpl(observable);\r\n        observable.AddObserver(observer);\r\n\r\n        observable.UpdateState();\r\n        observable.UpdateState();\r\n    }\r\n}", "#splitfile#\r\npublic interface #I1# {\r\n	#F;#I1#\r\n	\r\n	#M;#I1#\r\n    void Update();\r\n}\r\n#splitfile#\r\npublic class #CC1# implements #I1# {\r\n    private #CC2# observable;\r\n    private int state;\r\n	#F;#CC1#\r\n\r\n	#M;#CC1#\r\n    public #CC1#(#CC2# observable) {\r\n        this.observable = observable;\r\n    }\r\n\r\n    @Override\r\n    public void Update() {\r\n        state = observable.getState();\r\n        System.out.println(\"new state = \" + state);\r\n    }\r\n}\r\n#splitfile#\r\npublic abstract class #AC1# {\r\n    private List<#I1#> observers = new ArrayList<>();\r\n	#F;#AC1#\r\n\r\n	#M;#AC1#\r\n    public void addObserver(#I1# observer) {\r\n        observers.add(observer);\r\n    }\r\n\r\n    public void removeObserver(#I1# observer) {\r\n        observers.remove(observer);\r\n    }\r\n\r\n    public void notifyObservers() {\r\n        for (#I1# observer : observers) {\r\n            observer.Update();\r\n        }\r\n    }\r\n}\r\n#splitfile#\r\npublic class #CC2# extends #AC1# {\r\n    private int state;\r\n	#F;#CC2#\r\n	\r\n	#M;#CC2#\r\n    public void updateState() {\r\n        state++;\r\n        notifyObservers();\r\n    }\r\n\r\n    public int getState() {\r\n        return state;\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\npublic class Program {\r\n    public static void main(String[] args) {\r\n        #CC2# observable = new #CC2#();\r\n        #I1# observer = new #CC1#(observable);\r\n        observable.addObserver(observer);\r\n\r\n        observable.updateState();\r\n        observable.updateState();\r\n    }\r\n}", "#I1#Interfejs# #CC1#Obserwator# #AC1#Abstrakcyjnaklasa# #CC2#ObserwatorImpl# ", "Behavioral" },
                    { new Guid("ffb8c2cb-3b24-4bbe-b4bd-35061073ee98"), "The Singleton pattern ensures that a class has only one instance and provides a global point of access to that instance.", "", "", "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new NotImplementedException();\r\n    }", "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new UnsupportedOperationException(\"Not implemented yet\");\r\n    }", "", "", "#splitfile#\r\npublic sealed class #C#\r\n{ \r\n	private static #C# _instance;\r\n	#F;#C#\r\n\r\n	#M;#C#\r\n    private #C#() { }\r\n	\r\n    public static #C# GetInstance()\r\n    {\r\n        if (_instance == null)\r\n        {\r\n            _instance = new #C#();\r\n        }\r\n        return _instance;\r\n    }\r\n}", "#splitfile#\r\npublic final class #C# {\r\n    private static #C# _instance;\r\n    #F;#C#\r\n\r\n    #M;#C#\r\n    private #C#() { }\r\n    \r\n    public static synchronized #C# GetInstance() {\r\n        if (_instance == null) {\r\n            _instance = new #C#();\r\n        }\r\n        return _instance;\r\n    }\r\n}", "Singleton", "#splitfile#\r\npublic sealed class #CC1#\r\n{ \r\n	private static #CC1# _instance;\r\n	#F;#CC1#\r\n\r\n	#M;#CC1#\r\n    private #CC1#() { }\r\n	\r\n    public static #CC1# GetInstance()\r\n    {\r\n        if (_instance == null)\r\n        {\r\n            _instance = new #CC1#();\r\n        }\r\n        return _instance;\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        #CC1# s1 = #CC1#.GetInstance();\r\n        #CC1# s2 = #CC1#.GetInstance();\r\n    }\r\n}", "#splitfile#\r\npublic final class #CC1# {\r\n    private static #CC1# _instance;\r\n    #F;#CC1#\r\n\r\n    #M;#CC1#\r\n    private #CC1#() { }\r\n    \r\n    public static synchronized #CC1# GetInstance() {\r\n        if (_instance == null) {\r\n            _instance = new #CC1#();\r\n        }\r\n        return _instance;\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\npublic class Program {\r\n    public static void main(String[] args) {\r\n        #CC1# s1 = #CC1#.GetInstance();\r\n        #CC1# s2 = #CC1#.GetInstance();\r\n    }\r\n}", "#CC1#Singleton# ", "Creational" },
                    { new Guid("ffb8c2cb-3b34-4bbe-b4bd-35061073ee98"), "Chain of Responsibility is a behavioral design pattern that lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.", "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new NotImplementedException();\r\n    }", "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new UnsupportedOperationException(\"Not implemented yet\");\r\n    }", "\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new NotImplementedException();\r\n    }", "\r\n    @Override\r\n    public #TYPE# #NAME#(#PARAMS#){\r\n        throw new UnsupportedOperationException(\"Not implemented yet\");\r\n    }", "#TYPE# #NAME# (#PARAMS#);\n    ", "#TYPE# #NAME# (#PARAMS#);\n    ", "#splitfile#\r\nclass #C# : #AC1#\r\n{\r\n	#F;#C#\r\n\r\n	#M;#C#\r\n    public override object Handle(object request)\r\n    {\r\n        if (request.ToString() == \"Cup of coffee\") //change in your code\r\n        {\r\n			Console.Write($\"NewHandler: I'll eat the {request.ToString()}.\\n\");\r\n            return \"\";\r\n        }\r\n        else\r\n        {\r\n			Console.Write($\"NewHandler: I'm hungry!\\n\");\r\n            return base.Handle(request);\r\n        }\r\n    }\r\n}", "#splitfile#\r\nclass #C# extends #AC1# {\r\n    #F;#C#\r\n\r\n    #M;#C#\r\n    @Override\r\n    public Object Handle(Object request) {\r\n        if (request.toString().equals(\"Cup of coffee\")) {\r\n            System.out.print(\"NewHandler: I'll drink the \" + request.toString() + \".\\n\");\r\n            return \"\";\r\n        } else {\r\n            System.out.print(\"NewHandler: I'm thirsty!\\n\");\r\n            return super.Handle(request);\r\n        }\r\n    }\r\n}", "Chain of Responsibility", "#splitfile#\r\npublic interface #I1#\r\n{\r\n	#F;#I1#\r\n\r\n	#M;#I1#\r\n    #I1# SetNext(#I1# handler);\r\n    \r\n    object Handle(object request);\r\n}\r\n#splitfile#\r\nabstract class #AC1# : #I1#\r\n{\r\n    private #I1# _nextHandler;\r\n	#F;#AC1#\r\n\r\n	#M;#AC1#\r\n    public #I1# SetNext(#I1# handler)\r\n    {\r\n        this._nextHandler = handler;\r\n        \r\n        return handler;\r\n    }\r\n    \r\n    public virtual object Handle(object request)\r\n    {\r\n        if (this._nextHandler != null)\r\n        {\r\n            return this._nextHandler.Handle(request);\r\n        }\r\n        else\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n#splitfile#\r\nclass #CC1# : #AC1#\r\n{\r\n	#F;#CC1#\r\n\r\n	#M;#CC1#\r\n    public override object Handle(object request)\r\n    {\r\n        if ((request as string) == \"Pizza\")\r\n        {\r\n			Console.Write($\"Johny: I'll eat the {request.ToString()}.\\n\");\r\n            return \"\";\r\n        }\r\n        else\r\n        {\r\n			Console.Write($\"Johny: I'm hungry!\\n\");\r\n            return base.Handle(request);\r\n        }\r\n    }\r\n}\r\n#splitfile#\r\nclass #CC2# : #AC1#\r\n{\r\n	#F;#CC2#\r\n\r\n	#M;#CC2#\r\n    public override object Handle(object request)\r\n    {\r\n        if (request.ToString() == \"Donut\")\r\n        {\r\n			Console.Write($\"Arthur: I'll eat the {request.ToString()}.\\n\");\r\n            return \"\";\r\n        }\r\n        else\r\n        {\r\n			Console.Write($\"Arthur: I'm hungry!\\n\");\r\n            return base.Handle(request);\r\n        }\r\n    }\r\n}\r\n#splitfile#\r\nclass #CC3# : #AC1#\r\n{\r\n	#F;#CC3#\r\n\r\n	#M;#CC3#\r\n    public override object Handle(object request)\r\n    {\r\n        if (request.ToString() == \"Kebab\")\r\n        {\r\n			Console.Write($\"Tadeusz: I'll eat the {request.ToString()}.\\n\");\r\n            return \"\";\r\n        }\r\n        else\r\n        {\r\n			Console.Write($\"Tadeusz: I'm hungry!\\n\");\r\n            return base.Handle(request);\r\n        }\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        var handler1 = new #CC1#();\r\n        var handler2 = new #CC2#();\r\n        var handler3 = new #CC3#();\r\n\r\n        handler1.SetNext(handler2).SetNext(handler3);\r\n\r\n        foreach (var food in new List<string> { \"Pizza\", \"Kebab\", \"Cup of coffee\", \"Donut\" })\r\n        {\r\n            Console.WriteLine($\"Chef: Who wants a {food}?\");\r\n\r\n            var result = handler1.Handle(food);\r\n\r\n            if (result == null)\r\n            {\r\n                Console.WriteLine($\"   {food} was left untouched.\");\r\n            }\r\n        }\r\n    }\r\n}", "#splitfile#\r\npublic interface #I1# {\r\n    #F;#I1#\r\n\r\n    #M;#I1#\r\n    #I1# SetNext(#I1# handler);\r\n    \r\n    Object Handle(Object request);\r\n}\r\n#splitfile#\r\nabstract class #AC1# implements #I1# {\r\n    private #I1# _nextHandler;\r\n    #F;#AC1#\r\n\r\n    #M;#AC1#\r\n    public #I1# SetNext(#I1# handler) {\r\n        this._nextHandler = handler;\r\n        \r\n        return handler;\r\n    }\r\n    \r\n    public Object Handle(Object request) {\r\n        if (this._nextHandler != null) {\r\n            return this._nextHandler.Handle(request);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n#splitfile#\r\nclass #CC1# extends #AC1# {\r\n    #F;#CC1#\r\n\r\n    #M;#CC1#\r\n    @Override\r\n    public Object Handle(Object request) {\r\n        if (request.toString().equals(\"Pizza\")) {\r\n            System.out.print(\"Johny: I'll eat the \" + request.toString() + \".\\n\");\r\n            return \"\";\r\n        } else {\r\n            System.out.print(\"Johny: I'm hungry!\\n\");\r\n            return super.Handle(request);\r\n        }\r\n    }\r\n}\r\n#splitfile#\r\nclass #CC2# extends #AC1# {\r\n    #F;#CC2#\r\n\r\n    #M;#CC2#\r\n    @Override\r\n    public Object Handle(Object request) {\r\n        if (request.toString().equals(\"Donut\")) {\r\n            System.out.print(\"Arthur: I'll eat the \" + request.toString() + \".\\n\");\r\n            return \"\";\r\n        } else {\r\n            System.out.print(\"Arthur: I'm hungry!\\n\");\r\n            return super.Handle(request);\r\n        }\r\n    }\r\n}\r\n#splitfile#\r\nclass #CC3# extends #AC1# {\r\n    #F;#CC3#\r\n\r\n    #M;#CC3#\r\n    @Override\r\n    public Object Handle(Object request) {\r\n        if (request.toString().equals(\"Kebab\")) {\r\n            System.out.print(\"Tadeusz: I'll eat the \" + request.toString() + \".\\n\");\r\n            return \"\";\r\n        } else {\r\n            System.out.print(\"Tadeusz: I'm hungry!\\n\");\r\n            return super.Handle(request);\r\n        }\r\n    }\r\n}\r\n#DYNAMICS#\r\n#splitfile#\r\npublic class Program {\r\n    public static void main(String[] args) {\r\n        #CC1# handler1 = new #CC1#();\r\n        #CC2# handler2 = new #CC2#();\r\n        #CC3# handler3 = new #CC3#();\r\n\r\n        handler1.SetNext(handler2).SetNext(handler3);\r\n\r\n        List<String> foods = Arrays.asList(\"Pizza\", \"Kebab\", \"Cup of coffee\", \"Donut\");\r\n        for (String food : foods) {\r\n            System.out.println(\"Chef: Who wants a \" + food + \"?\");\r\n\r\n            Object result = handler1.Handle(food);\r\n\r\n            if (result == null) {\r\n                System.out.println(\"   \" + food + \" was left untouched.\");\r\n            }\r\n        }\r\n    }\r\n}", "#I1#IHandler# #AC1#AbstractHandler# #CC1#JohnyHandler# #CC2#ArthurHandler# #CC3#TadeuszHandler# ", "Behavioral" }
                });
        }

        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "Patterns");
        }
    }
}
